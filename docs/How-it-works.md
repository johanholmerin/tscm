# How it works

None of this is needed to use the library, it's purely for understanding how it works.

## TL;DR

The TypeScript compiler is patched so that the source code is modified before being parsed by TypeScript. An [Language Server Plugin](https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin) is added that translates positions between the original source and the modified code. Source maps are modified on emit by merging the maps from compiling TypeScript and from transforming macros.

## Long version

TypeScript is compiled to three files of interest, that each contain all of TypeScript, plus the specific parts for each file. They are:

- `typescript` - programmatic TypeScript compiler
- `tsc` - CLI compiler
- `tsserver` - Language Server for editor/IDE support

The files all export a single namespace, `ts`, which contains the methods that need to be changed. For the `tsserver` and `typescript` files it's enough to import the original file, patch, and re-export. This does not work for `tsc`, since, being a CLI, it self-executes when loaded, before it's possible to patch it. Therefore the file is instead read into a string, the executing call is removed so that the rest of the file can be executed, `ts` is patched, and then the removed line is executed to initialize the CLI.

### Patches

#### Adding LSP

_Only for `tsserver`_

A Language Server Plugin is added that translates source code positions.

- different positions in TS AST from source code
- LSP that translates positions before sending to tsserver and translates result

#### `host.getSourceFile`

Where the macro generation happens. Gets called with the source code, either from disk or from the editor in the case of `tsserver`, so that types and errors can be generated without saving the file. The source code is here parsed into an AST by Babel. Babel is used instead of TypeScript for several reasons:

1. Easier to use AST/more common
2. Faster
3. Enables using the same macros in Babel, minus the type-checking

The AST is then traversed, macro sites identified, and the macro functions called. For performance reasons, and to avoid unneccesary changes to the source code, only the generated node is stringified and the call site is replaced directly in the source code, using [Magic String](https://github.com/Rich-Harris/magic-string). A source map of the changes is also generated, and any errors are added to a list for inclusion in TypeScript diagnostics.

#### `host.writeFile`

Merges the source map generated by TypeScript compilation with the one generated from the macro replacements. Supports both inline and external source maps.

#### Diagnostics

Methods for getting diagnostics generated by TypeScript are patched for two reasons:

1. Filter out diagnostics that are from the macro replacements and may not be correct/useful
2. Mix in diagnostics generated from while generating macros
